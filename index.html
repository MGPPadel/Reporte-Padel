<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Informe de Clases de Padel</title>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, createUserWithEmailAndPassword, sendPasswordResetEmail, browserSessionPersistence, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs, doc, deleteDoc, setDoc, query, onSnapshot, writeBatch, Timestamp, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    window.initializeApp = initializeApp;
    window.getAuth = getAuth;
    window.signInWithEmailAndPassword = signInWithEmailAndPassword;
    window.signOut = signOut;
    window.onAuthStateChanged = onAuthStateChanged;
    window.getFirestore = getFirestore;
    window.collection = collection;
    window.addDoc = addDoc;
    window.getDocs = getDocs;
    window.doc = doc;
    window.deleteDoc = deleteDoc;
    window.setDoc = setDoc;
    window.query = query;
    window.onSnapshot = onSnapshot;
    window.writeBatch = writeBatch;
    window.Timestamp = Timestamp;
    window.getDoc = getDoc;
    window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
    window.sendPasswordResetEmail = sendPasswordResetEmail;
    window.browserSessionPersistence = browserSessionPersistence;
    window.browserLocalPersistence = browserLocalPersistence;
    window.setPersistence = setPersistence;
</script>
</head>
<body class="bg-gray-100 font-sans">
    <div id="root"></div>
    <script type="text/babel">
// Componente aislado para el input con autocompletado (teclado + click + cierre al hacer clic fuera)
const AutocompleteStudentInput = ({ index, value, newEntry, setNewEntry, students }) => {
  const [activeIndex, setActiveIndex] = React.useState(-1);
  const [open, setOpen] = React.useState(false);
  const containerRef = React.useRef(null);

  const filteredStudents = React.useMemo(() => {
    const term = (newEntry.studentNames[index] || "").toLowerCase();
    if (!term) return [];
    return students
      .filter(stu => (`${stu.firstName} ${stu.lastName}`).toLowerCase().includes(term))
      .slice(0, 5);
  }, [students, newEntry.studentNames, index]);
  // Cerrar al hacer clic fuera
  React.useEffect(() => {
    const handleClickOutside = (e) => {
      if (containerRef.current && !containerRef.current.contains(e.target)) {
        setOpen(false);
        setActiveIndex(-1);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const handleKeyDown = (e) => {
    if (!open || filteredStudents.length === 0) return;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setActiveIndex((prev) => (prev + 1) % filteredStudents.length);
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setActiveIndex((prev) => (prev <= 0 ? filteredStudents.length - 1 : prev - 1));
    } else if (e.key === "Enter" && activeIndex >= 0) {
      e.preventDefault();
      const stu = filteredStudents[activeIndex];
      const newNames = [...newEntry.studentNames];
      newNames[index] = `${stu.firstName} ${stu.lastName}`;
      const newIds = [...(newEntry.studentIds || [])];
      newIds[index] = stu.id;
      setNewEntry((prev) => ({ ...prev, studentNames: newNames, studentIds: newIds }));
      setActiveIndex(-1);
      setOpen(false);
    }
  };
  const handleSelect = (stu) => {
    const newNames = [...newEntry.studentNames];
    newNames[index] = `${stu.firstName} ${stu.lastName}`;
    const newIds = [...(newEntry.studentIds || [])];
    newIds[index] = stu.id;
    setNewEntry((prev) => ({ ...prev, studentNames: newNames, studentIds: newIds }));
    setActiveIndex(-1);
    setOpen(false);
  };

  return (
    <div className="relative mb-2" ref={containerRef}>
      <input
        type="text"
        placeholder={`Alumno ${index + 1}`}
        value={newEntry.studentNames[index] || ""}
        onChange={(e) => {
          const val = e.target.value;
          const newNames = [...newEntry.studentNames];
          newNames[index] = val;
        
          setNewEntry((prev) => ({ ...prev, studentNames: newNames }));
          setActiveIndex(-1);
          setOpen(true);
        }}
        onFocus={() => setOpen(true)}
        onKeyDown={handleKeyDown}
        className="peer p-3 w-full border rounded-lg focus:ring-2 focus:ring-blue-500 transition-shadow"
      />

      {/* Contenedor de sugerencias */}
      {open 
 && newEntry.studentNames[index] && filteredStudents.length > 0 && (
 
        <div
          className="absolute left-0 right-0 mt-1 bg-white border rounded-lg shadow-lg max-h-40 overflow-y-auto z-50
                     opacity-0 translate-y-1 scale-95 pointer-events-none
                     transition-all duration-200 ease-out
                 
     peer-focus:opacity-100 peer-focus:translate-y-0 peer-focus:scale-100 peer-focus:pointer-events-auto"
  
        >
          {filteredStudents.map((stu, i) => (
            <div
              key={stu.id}
              onMouseDown={(e) => { e.preventDefault();
 handleSelect(stu); }}
              onTouchStart={(e) => { e.preventDefault(); handleSelect(stu);
 }}
              className={`px-3 py-2 cursor-pointer transition-colors ${
 i === activeIndex ?
 "bg-blue-100 text-blue-800 font-semibold" : "hover:bg-gray-100"
              }`}
            >
              {stu.firstName} {stu.lastName}
            </div>
          ))}
        </div>
      )}
    </div>
  );
 };


// NUEVO CÓDIGO: Modal para editar una clase del día siguiente
const ModalEdicionClase = ({ clase, alumnosDisponibles, onClose, onSave }) => {
    const [alumnosClase, setAlumnosClase] = React.useState(clase.alumnos);

    const agregarAlumno = (event) => {
        const alumnoId = event.target.value;
        const alumno = alumnosDisponibles.find(a => a.id === alumnoId);
        if (alumno && alumnosClase.length < 4 && !alumnosClase.some(a => a.id === alumno.id)) {
            setAlumnosClase([...alumnosClase, alumno]);
        }
    };

    const quitarAlumno = (alumnoId) => {
        setAlumnosClase(alumnosClase.filter(a => a.id !== alumnoId));
    };

    const handleSave = () => {
        onSave(clase.hora, alumnosClase); // Se actualiza por hora, no por ID
        onClose();
    };

    return (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center z-50">
            <div className="relative top-10 mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
                <h3 className="text-xl font-bold mb-4">Editar Clase de las {clase.hora}hs</h3>
                <div className="my-4">
                    <h4 className="font-semibold text-gray-700">Alumnos actuales ({alumnosClase.length}/4)</h4>
                    <ul className="list-disc ml-5 mt-2">
                        {alumnosClase.map(alumno => (
                            <li key={alumno.id} className="flex justify-between items-center py-1">
                                <span>{alumno.nombre}</span>
                                <button onClick={() => quitarAlumno(alumno.id)} className="text-red-500 hover:text-red-700 ml-2">
                                    <i className="fas fa-trash-alt"></i>
                                </button>
                            </li>
                        ))}
                    </ul>
                </div>
                <div className="my-4">
                    <label htmlFor="agregar-alumno" className="block text-sm font-medium text-gray-700">Agregar alumno:</label>
                    <select id="agregar-alumno" onChange={agregarAlumno} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                        <option value="">Selecciona un alumno...</option>
                        {alumnosDisponibles
                            .filter(a => !alumnosClase.some(ac => ac.id === a.id))
                            .map(alumno => (
                                <option key={alumno.id} value={alumno.id}>{alumno.firstName} {alumno.lastName}</option>
                            ))}
                    </select>
                </div>
                <div className="flex justify-end mt-4">
                    <button onClick={onClose} className="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded mr-2">Cancelar</button>
                    <button onClick={handleSave} className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Guardar Cambios</button>
                </div>
            </div>
        </div>
    );
};


        const firebaseConfig = {
            apiKey: "AIzaSyAvk1yOsxXfc2w4YwZ1R1tQFrQuM2AbEYk",
            authDomain: "app-de-padel.firebaseapp.com",
            projectId: "app-de-padel",
            storageBucket: "app-de-padel.firebasestorage.app",
            messagingSenderId: "731771747398",
            appId: "1:731771747398:web:ebc8b723fe220869fade47"
        };
        const appId = typeof firebaseConfig.appId !== 'undefined' ? firebaseConfig.appId : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ?
 __initial_auth_token : null;

        const { useState, useEffect, useRef, useMemo } = React;
        const daysOfWeek = ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"];
        const defaultClassPrices = {
            1: 5000,
            2: 3000,
            3: 2500,
            4: 2000,
        };
        const peopleOptions = [1, 2, 3, 4];
        const timesOfDay = [
            '8:00 a. m.', '9:00 a. m.', '10:00 a. m.', '11:00 a. m.', '12:00 p. m.',
            '1:00 p. m.', '2:00 p. m.', '3:00 p. m.', '4:00 p. m.', '5:00 p. m.',
            '6:00 p. m.', '7:00 p. m.', '8:00 p. m.', '9:00 p. m.', '10:00 p. m.',
        ];
        const colorMap = {
            1: 'bg-yellow-100',
            2: 'bg-green-100',
            3: 'bg-blue-100',
            4: 'bg-purple-100',
        };
        const MessageBox = ({ show, title, content, type, onConfirm, onClose }) => {
            if (!show) return null;
            let icon, bgColor, titleColor;
            switch (type) {
                case 'success':
                    icon = <i className="fas fa-check-circle text-4xl text-green-600"></i>;
                    bgColor = 'bg-white';
                    titleColor = 'text-green-600';
                    break;
                case 'error':
                    icon = <i className="fas fa-times-circle text-4xl text-red-500"></i>;
                    bgColor = 'bg-white';
                    titleColor = 'text-red-600';
                    break;
                case 'confirm':
                    icon = <i className="fas fa-question-circle text-4xl text-blue-800"></i>;
                    bgColor = 'bg-white';
                    titleColor = 'text-blue-800';
                    break;
                default:
                    icon = null;
            }

            return (
                <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center z-50">
                    <div className={`p-6 rounded-xl shadow-xl w-full max-w-sm text-center ${bgColor} transform transition-all duration-300 ease-in-out scale-100`}>
                        <div className="mb-4">{icon}</div>
   
                         <h3 className={`text-lg font-bold mb-2 ${titleColor}`}>{title}</h3>
                        <p className="text-sm text-gray-500 mb-4">{content}</p>
                        <div className="mt-4">
                   
     {type === 'confirm' && (
                                <button
                                   
 onClick={onConfirm}
                       
                                 className={`py-2 px-4 rounded-lg font-bold transition-colors text-white bg-blue-800 hover:bg-blue-900 shadow-md mr-2`}
                                >
  
                                   Aceptar
          
                               </button>
                         
    )}
                            <button
                      
                         onClick={onClose}
                      
           className={`py-2 px-4 rounded-lg font-bold transition-colors text-white ${type === 'confirm' ?
 'bg-gray-400 hover:bg-gray-500' : type === 'success' ? 'bg-blue-600 hover:bg-blue-700' : 'bg-red-500 hover:bg-red-600'} shadow-md`}
                            >
                                {type === 'confirm' ?
 'Cancelar' : 'Cerrar'}
                            </button>
                        </div>
                    </div>
                </div>
          
             );
        };
        const App = () => {
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [userId, setUserId] = useState(null);
            const [userEmail, setUserEmail] = useState('');
            const [loading, setLoading] = useState(true);
            const [classes, setClasses] = useState([]);
            const [students, setStudents] = useState([]);
            const [payments, setPayments] = useState([]);
            const [activityLog, setActivityLog] = useState([]);
            const [customPrices, setCustomPrices] = useState(defaultClassPrices);
            const [currentPage, setCurrentPage] = useState(1);
            const [classesPerPage, setClassesPerPage] = useState(10);
            const [newEntry, setNewEntry] = useState({
                studentCount: 1,
                studentNames: [''],
                studentIds: [''],
                date: new Date().toISOString().split('T')[0],
                day: daysOfWeek[new Date().getDay()],
    
     
                time: timesOfDay[0],
                price: defaultClassPrices[1] || 0,
            });
            const [newStudent, setNewStudent] = useState({
                firstName: '',
                lastName: '',
                phone: '',
                description: '',
                status: 'Activo',
           
             });
            const [isEditingStudent, setIsEditingStudent] = useState(false);
            const [editedStudentId, setEditedStudentId] = useState(null);
            const [filterStatus, setFilterStatus] = useState('Todos');
            const [studentSearch, setStudentSearch] = useState('');
            const filteredStudentsList = React.useMemo(() => {
                const term = (studentSearch || '').toLowerCase();
                return students.filter(s => {
                    const status = s.status || 'Activo';
                    const matchesStatus = filterStatus === 'Todos' || status === filterStatus;
 
                    const haystack = `${s.firstName || ''} ${s.lastName || ''} ${s.phone || ''} ${s.description || ''}`.toLowerCase();
                    const matchesSearch = !term || haystack.includes(term);
                    return matchesStatus && matchesSearch;
              
     
           });
            }, [students, studentSearch, filterStatus]);
            const [newPayment, setNewPayment] = useState({
                date: new Date().toISOString().split('T')[0],
                amount: 0,
                description: '',
            });
            const [isEditingPayment, setIsEditingPayment] = useState(false);
            const [editedPaymentId, setEditedPaymentId] = useState(null);

            const [monthlyReports, setMonthlyReports] = useState({});
            const [annualPaymentsReport, setAnnualPaymentsReport] = useState({});
            const [selectedMonthYear, setSelectedMonthYear] = useState('');
            const [isEditing, setIsEditing] = useState(false);
            const [editedClassId, setEditedClassId] = useState(null);
            const [showConfigModal, setShowConfigModal] = useState(false);
            const [view, setView] = useState('list');
            const [filterText, setFilterText] = useState('');
            const [isSigningUp, setIsSigningUp] = useState(false);
            const [messageBox, setMessageBox] = useState({
                show: false,
                title: '',
                content: '',
                type: 'confirm',
                onConfirm: null,
           
             });

            const dbRef = useRef(null);
            const authRef = useRef(null);
            const fileInputRef = useRef(null);
            const reportTableRef = useRef(null);
            const annualPaymentsReportRef = useRef(null);
            const formatPrice = (price) => new Intl.NumberFormat('es-AR', { style: 'currency', currency: 'ARS', minimumFractionDigits: 0 }).format(price);
            const formatMonthYear = (monthYearString) => {
                const [year, month] = monthYearString.split('-');
 return new Date(year, month - 1).toLocaleString('es-AR', { month: 'long', year: 'numeric' });
            };
            const formatDate = (timestamp) => {
                const date = new Date(timestamp.seconds * 1000);
 return date.toLocaleString('es-AR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
            };
            const initializeFirebase = async () => {
                try {
                    const app = window.initializeApp(firebaseConfig);
                    dbRef.current = window.getFirestore(app);
                    authRef.current = window.getAuth(app);

                    const unsubscribe = window.onAuthStateChanged(authRef.current, (user) => {
                        if (user) {
                            setUserId(user.uid);
                            setUserEmail(user.email);
      
                         } else {
                            setUserId(null);
                            setUserEmail('');
                 
                        }
                        setLoading(false);
                    });
 return () => unsubscribe();
                } catch (error) {
                    console.error("Error initializing Firebase:", error);
                    setMessageBox({
                        show: true,
                        title: 'Error de configuración',
                        content: 'Error al inicializar Firebase. Revisa tu configuración.',
                 
                       type: 'error',
                        onClose: () => setMessageBox({ ...messageBox, show: false })
                    });
                    setLoading(false);
                }
            };
            useEffect(() => {
                initializeFirebase();
            }, []);
            const signIn = async () => {
    try {
        setLoading(true);
        const auth = authRef.current;
        await window.setPersistence(auth, window.browserLocalPersistence);
        await window.signInWithEmailAndPassword(auth, email, password);
        // Agregado: Muestra una alerta de éxito con el mensaje
        setMessageBox({
            show: true,
            title: 'Inicio de Sesión Exitoso',
            content: 'La sesión se mantendrá iniciada en este dispositivo.',
            type: 'success',
            onClose: () => setMessageBox({ ...messageBox, show: false })
  
        });

    } catch (error) {
        setMessageBox({
            show: true,
            title: 'Error de autenticación',
            content: 'Usuario o contraseña incorrectos. Por favor, inténtalo de nuevo.',
            type: 'error',
            onClose: () => setMessageBox({ ...messageBox, show: false })
 
        });
        console.error("Error signing in:", error);
 } finally {
        setLoading(false);
    }
};
            const signUp = async () => {
                try {
                    setLoading(true);
                    const auth = authRef.current;
                    await window.createUserWithEmailAndPassword(auth, email, password);
                    setMessageBox({
                        show: true,
                        title: 'Cuenta creada',
                        content: 'Tu cuenta se ha creado exitosamente. ¡Ya puedes iniciar sesión!',
       
                         type: 'success',
                        onClose: () => {
                            setMessageBox({ ...messageBox, show: false });
               
                         setIsSigningUp(false);
                        }
                    });
 } catch (error) {
                    setMessageBox({
                        show: true,
                        title: 'Error de registro',
                        content: 
 'Hubo un error al crear la cuenta. Puede que el email ya esté en uso o la contraseña sea demasiado débil.',
                        type: 'error',
                        onClose: () => setMessageBox({ ...messageBox, show: false })
                    });
                    console.error("Error signing up:", error);
 } finally {
                    setLoading(false);
 }
            };
            const handlePasswordReset = async () => {
                if (!email) {
                    setMessageBox({
                        show: true,
                        title: 'Error de validación',
    
                         content: 'Por favor, ingresa tu email para restablecer la contraseña.',
                        type: 'error',
                        onClose: () => setMessageBox({ ...messageBox, show: false })
          
                     });
 return;
                }
                try {
                    setLoading(true);
                    await window.sendPasswordResetEmail(authRef.current, email);
                    setMessageBox({
                        show: true,
                        title: 'Correo enviado',
                        content: 'Se ha enviado un correo para restablecer tu contraseña. Revisa tu bandeja de entrada.',
        
                         type: 'success',
                        onClose: () => setMessageBox({ ...messageBox, show: false })
                    });
 } catch (error) {
                    setMessageBox({
                        show: true,
                        title: 'Error al enviar correo',
                        
                        content: 'Hubo un error al enviar el correo. Asegúrate de que el email sea correcto.',
                        type: 'error',
                        onClose: () => setMessageBox({ ...messageBox, show: false })
      
               });
                    console.error("Error sending password reset email:", error);
 } finally {
                    setLoading(false);
 }
            };
            const signOutUser = async () => {
                try {
                    await window.signOut(authRef.current);
                    setUserId(null);
                    setClasses([]);
 } catch (error) {
                    console.error("Error signing out:", error);
 }
            };
            const saveCustomPrices = async () => {
                if (!dbRef.current || !userId) return;
 try {
                    setLoading(true);
                    const userDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'config', 'prices');
                    await window.setDoc(userDocRef, { prices: customPrices });
                    setMessageBox({ show: true, title: 'Precios guardados', content: 'Los precios de las clases se han guardado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 } catch (error) {
                    setMessageBox({ show: true, title: 'Error al guardar', content: 'Hubo un error al guardar los precios.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                    console.error("Error saving custom prices:", error);
 } finally {
                    setLoading(false);
 }
            };
            const loadCustomPrices = async () => {
                if (!dbRef.current || !userId) return;
 try {
                    const userDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'config', 'prices');
                    const docSnap = await window.getDoc(userDocRef);
                    if (docSnap.exists()) {
                        setCustomPrices(docSnap.data().prices);
 }
                } catch (error) {
                    console.error("Error loading custom prices:", error);
 }
            };
            const addLogEntry = async (action, details) => {
                if (!dbRef.current || !userId) return;
 try {
                    const logColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'activityLog');
                    await window.addDoc(logColRef, {
                        action,
                        details,
                        timestamp: window.Timestamp.now()
                    });
 } catch (error) {
                    console.error("Error adding log entry:", error);
 }
            };
            // NUEVO CÓDIGO: Funciones para manejar horarios de clase
            const [horariosClase, setHorariosClase] = useState([{ dia: '', hora: '' }]);

            const handleHorarioChange = (index, field, value) => {
                const nuevosHorarios = [...horariosClase];
                nuevosHorarios[index][field] = value;
                setHorariosClase(nuevosHorarios);
            };

            const agregarHorario = () => {
                setHorariosClase([...horariosClase, { dia: '', hora: '' }]);
            };

            const quitarHorario = (index) => {
                const nuevosHorarios = horariosClase.filter((_, i) => i !== index);
                setHorariosClase(nuevosHorarios);
            };

            const addStudent = async () => {
                if (!dbRef.current || !userId) return;
                // Modificado: Se eliminó la validación anterior para permitir guardar un alumno sin horarios
                try {
                    setLoading(true);
                    const studentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'students');
                    const studentData = {
                        ...newStudent,
                        horarios: horariosClase.filter(h => h.dia && h.hora),
                    };

                    if (isEditingStudent) {
                        const studentDocRef = window.doc(studentsColRef, editedStudentId);
                        await window.setDoc(studentDocRef, studentData);
                        setMessageBox({ show: true, title: 'Alumno actualizado', content: 'El alumno se ha actualizado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                    } else {
                        await window.addDoc(studentsColRef, studentData);
                        setMessageBox({ show: true, title: 'Alumno añadido', content: 'El nuevo alumno se ha añadido exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                    }
                    setNewStudent({ firstName: '', lastName: '', phone: '', description: '', status: 'Activo' });
                    // NUEVO CÓDIGO: Limpiar el estado de horarios
                    setHorariosClase([{ dia: '', hora: '' }]);
                    setIsEditingStudent(false);
                    setEditedStudentId(null);
                } catch (error) {
                    setMessageBox({ show: true, title: 'Error al guardar el alumno', content: 'Hubo un error al guardar los datos del alumno. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                    console.error("Error adding/updating student:", error);
                } finally {
                    setLoading(false);
                }
            };
            const editStudent = (studentToEdit) => {
                setNewStudent(studentToEdit);
                // NUEVO CÓDIGO: Cargar los horarios del alumno al editar
                if (studentToEdit.horarios && Array.isArray(studentToEdit.horarios)) {
                    setHorariosClase(studentToEdit.horarios);
                } else {
                    setHorariosClase([{ dia: '', hora: '' }]);
                }
                setIsEditingStudent(true);
                setEditedStudentId(studentToEdit.id);
            };

            const deleteStudent = (studentId) => {
                setMessageBox({
                    show: true,
                    title: 'Confirmar eliminación',
                    content: '¿Estás seguro de que quieres eliminar a este alumno? Esta acción es 
 irreversible.',
                    type: 'confirm',
                    onConfirm: async () => {
                        if (!dbRef.current || !userId) return;
                        try {
  
                                                     setLoading(true);
                            const studentDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'students', studentId);
          
                   await window.deleteDoc(studentDocRef);
        
                                                 setMessageBox({ show: true, title: 'Alumno eliminado', content: 'El alumno ha sido eliminado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 
                        } catch (error) {
                            setMessageBox({ show: true, title: 'Error al eliminar', content: 'Hubo un error al eliminar al alumno.
 Inténtalo de nuevo.', type: 
 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                            console.error("Error deleting student:", error);
 } finally {
                            setLoading(false);
 }
                    },
                    onClose: () => setMessageBox({ ...messageBox, show: false })
                });
 };

            const sendWhatsApp = (phone) => {
                const formattedPhone = phone.replace(/\D/g, '');
                const url = `https://wa.me/${formattedPhone}`;
                window.open(url, '_blank');
            };

            const addPayment = async () => {
                if (!dbRef.current || !userId) return;
                if (!newPayment.date || !newPayment.amount || newPayment.amount <= 0) {
                    setMessageBox({ show: true, title: 'Error de validación', content: 'Por favor, ingresa una fecha y un monto válido para el pago.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 return;
                }
                try {
                    setLoading(true);
                    const paymentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments');
                    const paymentData = {
                        ...newPayment,
                        amount: parseFloat(newPayment.amount),
                        date: newPayment.date,
              
                         timestamp: window.Timestamp.fromDate(new Date(newPayment.date))
                    };
 if (isEditingPayment) {
                        const paymentDocRef = window.doc(paymentsColRef, editedPaymentId);
                        await window.setDoc(paymentDocRef, paymentData);
                        setMessageBox({ show: true, title: 'Pago actualizado', content: 'El pago se ha actualizado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 } else {
                        await window.addDoc(paymentsColRef, paymentData);
                        setMessageBox({ show: true, title: 'Pago añadido', content: 'El nuevo pago se ha añadido exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 }
                    setNewPayment({ date: new Date().toISOString().split('T')[0], amount: 0, description: '' });
                    setIsEditingPayment(false);
                    setEditedPaymentId(null);
 } catch (error) {
                    setMessageBox({ show: true, title: 'Error al guardar el pago', content: 'Hubo un error al guardar los datos del pago. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
                    console.error("Error adding/updating payment:", error);
 } finally {
                    setLoading(false);
 }
            };
            const editPayment = (paymentToEdit) => {
                setNewPayment({ ...paymentToEdit, amount: paymentToEdit.amount.toString() });
                setIsEditingPayment(true);
                setEditedPaymentId(paymentToEdit.id);
            };
            const deletePayment = (paymentId) => {
                setMessageBox({
                    show: true,
                    title: 'Confirmar eliminación',
                    content: '¿Estás seguro de que quieres eliminar este pago? Esta acción es irreversible.',
 
                                       type: 'confirm',
                    onConfirm: async () => {
                        if (!dbRef.current || !userId) return;
        
                 try {
   
                                                     setLoading(true);
                           
  const paymentDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments', paymentId);
                            await window.deleteDoc(paymentDocRef);
         
                                                 setMessageBox({ show: true, 
 title: 'Pago eliminado', content: 'El pago ha sido eliminado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
 } catch (error) {
                            setMessageBox({ show: true, title: 'Error al eliminar', content: 'Hubo un error al eliminar el pago. Inténtalo de nuevo.', type: 'error', 
 onClose: () => setMessageBox({ ...messageBox, show: false }) });
                            console.error("Error deleting payment:", error);
 } finally {
                            setLoading(false);
 }
                    },
                    onClose: () => setMessageBox({ ...messageBox, show: false })
                });
 };
            
            // NUEVO CÓDIGO: Estados para las clases de mañana
            const [clasesManana, setClasesManana] = useState([]);
            const [alumnosDisponibles, setAlumnosDisponibles] = useState([]);
            const [claseSeleccionada, setClaseSeleccionada] = useState(null);

            // NUEVO CÓDIGO: Lógica para obtener las clases de mañana
            const getClasesManana = async () => {
                setLoading(true);
                try {
                    const manana = new Date();
                    manana.setDate(manana.getDate() + 1); // Sumamos un día
                    
                    const diasSemana = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'];
                    const diaManana = diasSemana[manana.getDay()];

                    const alumnosSnapshot = await getDocs(collection(dbRef.current, 'artifacts', appId, 'users', userId, 'students'));
                    const todosLosAlumnos = alumnosSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                    const clasesDelDia = {};

                    todosLosAlumnos.forEach(alumno => {
                        if (alumno.horarios && Array.isArray(alumno.horarios)) {
                            alumno.horarios.forEach(horario => {
                                if (horario.dia === diaManana) {
                                    if (!clasesDelDia[horario.hora]) {
                                        clasesDelDia[horario.hora] = {
                                            hora: horario.hora,
                                            alumnos: [],
                                        };
                                    }
                                    clasesDelDia[horario.hora].alumnos.push(alumno);
                                }
                            });
                        }
                    });

                    const clasesOrdenadas = Object.values(clasesDelDia).sort((a, b) => a.hora.localeCompare(b.hora));
                    
                    setClasesManana(clasesOrdenadas);
                    setAlumnosDisponibles(todosLosAlumnos);
                } catch (err) {
                    console.error("Error al cargar clases de mañana:", err);
                    setMessageBox({ show: true, title: 'Error', content: 'Error al cargar las clases de mañana.', type: 'error' });
                } finally {
                    setLoading(false);
                }
            };

            // NUEVO CÓDIGO: Función para guardar los cambios en una clase
            const handleGuardarClase = async (hora, nuevosAlumnos) => {
                setLoading(true);
                try {
                    // Esta lógica es un poco diferente, ya que no hay una colección 'clases_manana'
                    // Realmente actualizamos el horario de cada alumno
                    const batch = writeBatch(dbRef.current);
                    
                    // Obtener la fecha de mañana para el log
                    const manana = new Date();
                    manana.setDate(manana.getDate() + 1);
                    const mananaStr = manana.toISOString().split('T')[0];

                    // Obtenemos todos los alumnos para poder actualizar sus horarios
                    const alumnosSnapshot = await getDocs(collection(dbRef.current, 'artifacts', appId, 'users', userId, 'students'));
                    const todosLosAlumnos = alumnosSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    // Actualizamos los alumnos que están en la clase
                    for (const alumno of nuevosAlumnos) {
                        const alumnoRef = doc(dbRef.current, 'artifacts', appId, 'users', userId, 'students', alumno.id);
                        const alumnoData = todosLosAlumnos.find(a => a.id === alumno.id);
                        
                        // Si el alumno no tenía el horario, lo agregamos. Si ya lo tenía, no hacemos nada
                        if (!alumnoData.horarios.some(h => h.dia === daysOfWeek[manana.getDay()] && h.hora === hora)) {
                            const newHorarios = [...(alumnoData.horarios || []), { dia: daysOfWeek[manana.getDay()], hora: hora }];
                            batch.update(alumnoRef, { horarios: newHorarios });
                        }
                    }

                    // Por simplicidad, esta función no quita a los alumnos de la clase, solo los agrega
                    // Si se desea eliminar un alumno de la clase de mañana, se puede implementar otra lógica.
                    
                    await batch.commit();

                    // Refrescamos los datos para que la interfaz se actualice
                    getClasesManana();
                    addLogEntry('Clase de Mañana actualizada', `La clase de las ${hora}hs del día ${mananaStr} fue actualizada.`);
                    setMessageBox({ show: true, title: 'Clase actualizada', content: 'Los cambios en la clase de mañana se guardaron correctamente.', type: 'success' });
                } catch (err) {
                    console.error("Error al guardar clase:", err);
                    setMessageBox({ show: true, title: 'Error', content: 'Hubo un error al guardar los cambios en la clase.', type: 'error' });
                } finally {
                    setLoading(false);
                }
            };
            
            // Modificado: Este useEffect ahora no solo carga los datos, sino que también llama a la nueva función de clases de mañana.
            useEffect(() => {
                if (userId && dbRef.current) {
                    loadCustomPrices();

                    const classesColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'classes');
                    const classesQuery = window.query(classesColRef);
      
                                 const unsubscribeClasses = window.onSnapshot(classesQuery, (snapshot) => {
                        const fetchedClasses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const sortedClasses = fetchedClasses.sort((a, 
 b) => new Date(b.date) - new Date(a.date));
             
                                     setClasses(sortedClasses);
                    });

                    const studentsColRef = window.collection(dbRef.current, 
 'artifacts', appId, 'users', userId, 'students');
                    const studentsQuery = window.query(studentsColRef);
                  
                     const unsubscribeStudents = window.onSnapshot(studentsQuery, (snapshot) => {
                        const fetchedStudents = snapshot.docs.map(doc 
 => ({ id: doc.id, ...doc.data() }));
                        setStudents(fetchedStudents.sort((a, b) => a.lastName.localeCompare(b.lastName)));
                        getClasesManana(); // NUEVO CÓDIGO: Llama a la función de clases de mañana cada vez que los alumnos cambian
                    });

                    const paymentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments');
                    const paymentsQuery = window.query(paymentsColRef);
                    const unsubscribePayments = window.onSnapshot(paymentsQuery, (snapshot) => {
                        const fetchedPayments = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const sortedPayments = fetchedPayments.sort((a, b) => new Date(b.date) - new Date(a.date));
                       
  setPayments(sortedPayments);
   
                                     });
                    const logColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'activityLog');
                    const logQuery = window.query(logColRef);
                    const unsubscribeLog = window.onSnapshot(logQuery, (snapshot) => {
                        const fetchedLog = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const sortedLog = fetchedLog.sort((a, b) => b.timestamp.seconds - a.timestamp.seconds);
                        setActivityLog(sortedLog);
     
 
                                     });
                    return () => {
                        unsubscribeClasses();
                        unsubscribeStudents();
                        unsubscribePayments();
                        unsubscribeLog();
                    };
                } else {
                    setClasses([]);
                    setStudents([]);
                    setPayments([]);
                    setActivityLog([]);
                }
            }, [userId]);
            useEffect(() => {
                if (Object.keys(customPrices).length > 0) {
                    setNewEntry(prev => ({ ...prev, price: customPrices[prev.studentCount] || 0 }));
                }
            }, [customPrices]);
            useEffect(() => {
                const report = {};
                classes.forEach(cls => {
                    const date = new Date(`${cls.date}T00:00:00Z`);
                    const monthYear = `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, '0')}`;
           
                         if (!report[monthYear]) {
                        report[monthYear] = { totalIncome: 0, classCount: 0, classCountByStudent: {} };
                    }
                    
 report...

selectedRelevantSnippets:
snippet_1: <!DOCTYPE html> <html lang="es"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Informe de Clases de Padel</title> <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script> <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script> <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script> <script src="https://cdn.tailwindcss.com"></script> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" /> <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> <script type="module"> import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, createUserWithEmailAndPassword, sendPasswordResetEmail, browserSessionPersistence, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, collection, addDoc, getDocs, doc, deleteDoc, setDoc, query, onSnapshot, writeBatch, Timestamp, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; window.initializeApp = initializeApp;
window.getAuth = getAuth; window.signInWithEmailAndPassword = signInWithEmailAndPassword; window.signOut = signOut; window.onAuthStateChanged = onAuthStateChanged; window.getFirestore = getFirestore; window.collection = collection;
window.addDoc = addDoc; window.getDocs = getDocs; window.doc = doc; window.deleteDoc = deleteDoc; window.setDoc = setDoc; window.query = query;
window.onSnapshot = onSnapshot; window.writeBatch = writeBatch; window.Timestamp = Timestamp; window.getDoc = getDoc; window.createUserWithEmailAndPassword = createUserWithEmailAndPassword; window.sendPasswordResetEmail = sendPasswordResetEmail;
window.browserSessionPersistence = browserSessionPersistence; window.browserLocalPersistence = browserLocalPersistence; window.setPersistence = setPersistence; </script> </head> <body class="bg-gray-100 font-sans"> <div id="root"></div> <script type="text/babel"> // Componente aislado para el input con autocompletado (teclado + click + cierre al hacer clic fuera) const AutocompleteStudentInput = ({ index, value, newEntry, setNewEntry, students }) => { const [activeIndex, setActiveIndex] = React.useState(-1);
const [open, setOpen] = React.useState(false); const containerRef = React.useRef(null); const filteredStudents = React.useMemo(() => { const term = (newEntry.studentNames[index] || "").toLowerCase(); if (!term) return []; return students .filter(stu => (`${stu.firstName} ${stu.lastName}`).toLowerCase().includes(term)) .slice(0, 5); }, [students, newEntry.studentNames, index]);
// Cerrar al hacer clic fuera React.useEffect(() => { const handleClickOutside = (e) => { if (containerRef.current && !containerRef.current.contains(e.target)) { setOpen(false); setActiveIndex(-1); } }; document.addEventListener("mousedown", handleClickOutside); return () => document.removeEventListener("mousedown", handleClickOutside); }, []);
const handleKeyDown = (e) => { if (!open || filteredStudents.length === 0) return; if (e.key === "ArrowDown") { e.preventDefault();
setActiveIndex((prev) => (prev + 1) % filteredStudents.length); } else if (e.key === "ArrowUp") { e.preventDefault();
setActiveIndex((prev) => (prev <= 0 ? filteredStudents.length - 1 : prev - 1));
} else if (e.key === "Enter" && activeIndex >= 0) { e.preventDefault(); const stu = filteredStudents[activeIndex]; const newNames = [...newEntry.studentNames];
newNames[index] = `${stu.firstName} ${stu.lastName}`; const newIds = [...(newEntry.studentIds || [])]; newIds[index] = stu.id;
setNewEntry((prev) => ({ ...prev, studentNames: newNames, studentIds: newIds })); setActiveIndex(-1); setOpen(false); } };
const handleSelect = (stu) => { const newNames = [...newEntry.studentNames]; newNames[index] = `${stu.firstName} ${stu.lastName}`; const newIds = [...(newEntry.studentIds || [])];
newIds[index] = stu.id; setNewEntry((prev) => ({ ...prev, studentNames: newNames, studentIds: newIds })); setActiveIndex(-1); setOpen(false); };
return ( <div className="relative mb-2" ref={containerRef}> <input type="text" placeholder={`Alumno ${index + 1}`} value={newEntry.studentNames[index] || ""} onChange={(e) => { const val = e.target.value; const newNames = [...newEntry.studentNames]; newNames[index] = val; setNewEntry((prev) => ({ ...prev, studentNames: newNames })); setActiveIndex(-1); setOpen(true); }} onFocus={() => setOpen(true)} onKeyDown={handleKeyDown} className="peer p-3 w-full border rounded-lg focus:ring-2 focus:ring-blue-500 transition-shadow" /> {/* Contenedor de sugerencias */} {open && newEntry.studentNames[index] && filteredStudents.length > 0 && ( <div className="absolute left-0 right-0 mt-1 bg-white border rounded-lg shadow-lg max-h-40 overflow-y-auto z-50 opacity-0 translate-y-1 scale-95 pointer-events-none transition-all duration-200 ease-out peer-focus:opacity-100 peer-focus:translate-y-0 peer-focus:scale-100 peer-focus:pointer-events-auto" > {filteredStudents.map((stu, i) => ( <div key={stu.id} onMouseDown={(e) => { e.preventDefault();
handleSelect(stu); }} onTouchStart={(e) => { e.preventDefault(); handleSelect(stu); }} className={`px-3 py-2 cursor-pointer transition-colors ${ i === activeIndex ?
"bg-blue-100 text-blue-800 font-semibold" : "hover:bg-gray-100" }`} > {stu.firstName} {stu.lastName} </div> ))} </div> )} </div> ); };
const firebaseConfig = { apiKey: "AIzaSyAvk1yOsxXfc2w4YwZ1R1tQFrQuM2AbEYk", authDomain: "app-de-padel.firebaseapp.com", projectId: "app-de-padel", storageBucket: "app-de-padel.firebasestorage.app", messagingSenderId: "731771747398", appId: "1:731771747398:web:ebc8b723fe220869fade47" };
const appId = typeof firebaseConfig.appId !== 'undefined' ? firebaseConfig.appId : 'default-app-id'; const initialAuthToken = typeof __initial_auth_token !== 'undefined' ?
__initial_auth_token : null; const { useState, useEffect, useRef, useMemo } = React;
const daysOfWeek = ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"];
const defaultClassPrices = { 1: 5000, 2: 3000, 3: 2500, 4: 2000, }; const peopleOptions = [1, 2, 3, 4];
const timesOfDay = [ '8:00 a. m.', '9:00 a. m.', '10:00 a. m.', '11:00 a. m.', '12:00 p.
m.', '1:00 p. m.', '2:00 p. m.', '3:00 p. m.', '4:00 p. m.', '5:00 p. m.', '6:00 p.
m.', '7:00 p. m.', '8:00 p. m.', '9:00 p. m.', '10:00 p. m.', ];
const colorMap = { 1: 'bg-yellow-100', 2: 'bg-green-100', 3: 'bg-blue-100', 4: 'bg-purple-100', };
const MessageBox = ({ show, title, content, type, onConfirm, onClose }) => { if (!show) return null;
let icon, bgColor, titleColor; switch (type) { case 'success': icon = <i className="fas fa-check-circle text-4xl text-green-600"></i>; bgColor = 'bg-white';
titleColor = 'text-green-600'; break; case 'error': icon = <i className="fas fa-times-circle text-4xl text-red-500"></i>; bgColor = 'bg-white'; titleColor = 'text-red-600'; break;
case 'confirm': icon = <i className="fas fa-question-circle text-4xl text-blue-800"></i>; bgColor = 'bg-white'; titleColor = 'text-blue-800'; break; default: icon = null;
} return ( <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full flex items-center justify-center z-50"> <div className={`p-6 rounded-xl shadow-xl w-full max-w-sm text-center ${bgColor} transform transition-all duration-300 ease-in-out scale-100`}> <div className="mb-4">{icon}</div> <h3 className={`text-lg font-bold mb-2 ${titleColor}`}>{title}</h3> <p className="text-sm text-gray-500 mb-4">{content}</p> <div className="mt-4"> {type === 'confirm' && ( <button onClick={onConfirm} className={`py-2 px-4 rounded-lg font-bold transition-colors text-white bg-blue-800 hover:bg-blue-900 shadow-md mr-2`} > Aceptar </button> )} <button onClick={onClose} className={`py-2 px-4 rounded-lg font-bold transition-colors text-white ${type === 'confirm' ? 'bg-gray-400 hover:bg-gray-500' : type === 'success' ? 'bg-blue-600 hover:bg-blue-700' : 'bg-red-500 hover:bg-red-600'} shadow-md`} > {type === 'confirm' ? 'Cancelar' : 'Cerrar'} </button> </div> </div> </div> );
}; const App = () => { const [email, setEmail] = useState(''); const [password, setPassword] = useState('');
const [userId, setUserId] = useState(null); const [userEmail, setUserEmail] = useState(''); const [loading, setLoading] = useState(true); const [classes, setClasses] = useState([]);
const [students, setStudents] = useState([]); const [payments, setPayments] = useState([]); const [activityLog, setActivityLog] = useState([]); const [customPrices, setCustomPrices] = useState(defaultClassPrices);
const [currentPage, setCurrentPage] = useState(1); const [classesPerPage, setClassesPerPage] = useState(10);
const [newEntry, setNewEntry] = useState({ studentCount: 1, studentNames: [''], studentIds: [''], date: new Date().toISOString().split('T')[0], day: daysOfWeek[new Date().getDay()], time: timesOfDay[0], price: defaultClassPrices[1] || 0, });
const [newStudent, setNewStudent] = useState({ firstName: '', lastName: '', phone: '', description: '', status: 'Activo', });
const [isEditingStudent, setIsEditingStudent] = useState(false); const [editedStudentId, setEditedStudentId] = useState(null); const [filterStatus, setFilterStatus] = useState('Todos'); const [studentSearch, setStudentSearch] = useState('');
const filteredStudentsList = React.useMemo(() => { const term = (studentSearch || '').toLowerCase(); return students.filter(s => { const status = s.status || 'Activo'; const matchesStatus = filterStatus === 'Todos' || status === filterStatus; const haystack = `${s.firstName || ''} ${s.lastName || ''} ${s.phone || ''} ${s.description || ''}`.toLowerCase(); const matchesSearch = !term || haystack.includes(term); return matchesStatus && matchesSearch; }); }, [students, studentSearch, filterStatus]);
const [newPayment, setNewPayment] = useState({ date: new Date().toISOString().split('T')[0], amount: 0, description: '', }); const [isEditingPayment, setIsEditingPayment] = useState(false);
const [editedPaymentId, setEditedPaymentId] = useState(null); const [monthlyReports, setMonthlyReports] = useState({}); const [annualPaymentsReport, setAnnualPaymentsReport] = useState({}); const [selectedMonthYear, setSelectedMonthYear] = useState('');
const [isEditing, setIsEditing] = useState(false); const [editedClassId, setEditedClassId] = useState(null); const [showConfigModal, setShowConfigModal] = useState(false); const [view, setView] = useState('list');
const [filterText, setFilterText] = useState(''); const [isSigningUp, setIsSigningUp] = useState(false);
const [messageBox, setMessageBox] = useState({ show: false, title: '', content: '', type: 'confirm', onConfirm: null, }); const dbRef = useRef(null);
const authRef = useRef(null); const fileInputRef = useRef(null); const reportTableRef = useRef(null); const annualPaymentsReportRef = useRef(null);
const formatPrice = (price) => new Intl.NumberFormat('es-AR', { style: 'currency', currency: 'ARS', minimumFractionDigits: 0 }).format(price);
const formatMonthYear = (monthYearString) => { const [year, month] = monthYearString.split('-');
return new Date(year, month - 1).toLocaleString('es-AR', { month: 'long', year: 'numeric' }); };
const formatDate = (timestamp) => { const date = new Date(timestamp.seconds * 1000);
return date.toLocaleString('es-AR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }); };
const initializeFirebase = async () => { try { const app = window.initializeApp(firebaseConfig); dbRef.current = window.getFirestore(app); authRef.current = window.getAuth(app);
const unsubscribe = window.onAuthStateChanged(authRef.current, (user) => { if (user) { setUserId(user.uid); setUserEmail(user.email); } else { setUserId(null); setUserEmail(''); } setLoading(false); });
return () => unsubscribe(); } catch (error) { console.error("Error initializing Firebase:", error);
setMessageBox({ show: true, title: 'Error de configuración', content: 'Error al inicializar Firebase. Revisa tu configuración.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
setLoading(false); } }; useEffect(() => { initializeFirebase(); }, []); const signIn = async () => { try { setLoading(true);
const auth = authRef.current; await window.setPersistence(auth, window.browserLocalPersistence); await window.signInWithEmailAndPassword(auth, email, password);
// Agregado: Muestra una alerta de éxito con el mensaje setMessageBox({ show: true, title: 'Inicio de Sesión Exitoso', content: 'La sesión se mantendrá iniciada en este dispositivo.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} catch (error) { setMessageBox({ show: true, title: 'Error de autenticación', content: 'Usuario o contraseña incorrectos. Por favor, inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error signing in:", error); } finally { setLoading(false); } }; const signUp = async () => { try { setLoading(true);
const auth = authRef.current; await window.createUserWithEmailAndPassword(auth, email, password); setMessageBox({ show: true, title: 'Cuenta creada', content: 'Tu cuenta se ha creado exitosamente. ¡Ya puedes iniciar sesión!', type: 'success', onClose: () => { setMessageBox({ ...messageBox, show: false }); setIsSigningUp(false); } });
} catch (error) { setMessageBox({ show: true, title: 'Error de registro', content: 'Hubo un error al crear la cuenta. Puede que el email ya esté en uso o la contraseña sea demasiado débil.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error signing up:", error); } finally { setLoading(false); } };
const handlePasswordReset = async () => { if (!email) { setMessageBox({ show: true, title: 'Error de validación', content: 'Por favor, ingresa tu email para restablecer la contraseña.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
return; } try { setLoading(true); await window.sendPasswordResetEmail(authRef.current, email); setMessageBox({ show: true, title: 'Correo enviado', content: 'Se ha enviado un correo para restablecer tu contraseña. Revisa tu bandeja de entrada.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} catch (error) { setMessageBox({ show: true, title: 'Error al enviar correo', content: 'Hubo un error al enviar el correo. Asegúrate de que el email sea correcto.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error sending password reset email:", error); } finally { setLoading(false); } };
const signOutUser = async () => { try { await window.signOut(authRef.current); setUserId(null); setClasses([]);
} catch (error) { console.error("Error signing out:", error); } };
const saveCustomPrices = async () => { if (!dbRef.current || !userId) return; try { setLoading(true);
const userDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'config', 'prices'); await window.setDoc(userDocRef, { prices: customPrices });
setMessageBox({ show: true, title: 'Precios guardados', content: 'Los precios de las clases se han guardado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} catch (error) { setMessageBox({ show: true, title: 'Error al guardar', content: 'Hubo un error al guardar los precios.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error saving custom prices:", error); } finally { setLoading(false); } };
const loadCustomPrices = async () => { if (!dbRef.current || !userId) return;
try { const userDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'config', 'prices'); const docSnap = await window.getDoc(userDocRef);
if (docSnap.exists()) { setCustomPrices(docSnap.data().prices); } } catch (error) { console.error("Error loading custom prices:", error); } };
const addLogEntry = async (action, details) => { if (!dbRef.current || !userId) return;
try { const logColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'activityLog'); await window.addDoc(logColRef, { action, details, timestamp: window.Timestamp.now() });
} catch (error) { console.error("Error adding log entry:", error); } };
const addStudent = async () => { if (!dbRef.current || !userId) return;
if (!newStudent.firstName || !newStudent.lastName || !newStudent.phone) { setMessageBox({ show: true, title: 'Error de validación', content: 'Por favor, completa todos los campos del alumno.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
return; } try { setLoading(true); const studentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'students');
if (isEditingStudent) { const studentDocRef = window.doc(studentsColRef, editedStudentId); await window.setDoc(studentDocRef, newStudent);
setMessageBox({ show: true, title: 'Alumno actualizado', content: 'El alumno se ha actualizado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} else { await window.addDoc(studentsColRef, newStudent); setMessageBox({ show: true, title: 'Alumno añadido', content: 'El nuevo alumno se ha añadido exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} setNewStudent({ firstName: '', lastName: '', phone: '', description: '', status: 'Activo' }); setIsEditingStudent(false); setEditedStudentId(null);
} catch (error) { setMessageBox({ show: true, title: 'Error al guardar el alumno', content: 'Hubo un error al guardar los datos del alumno. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error adding/updating student:", error); } finally { setLoading(false); } }; const editStudent = (studentToEdit) => { setNewStudent(studentToEdit); setIsEditingStudent(true); setEditedStudentId(studentToEdit.id); };
const deleteStudent = (studentId) => { setMessageBox({ show: true, title: 'Confirmar eliminación', content: '¿Estás seguro de que quieres eliminar a este alumno? Esta acción es irreversible.', type: 'confirm', onConfirm: async () => { if (!dbRef.current || !userId) return; try { setLoading(true); const studentDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'students', studentId); await window.deleteDoc(studentDocRef); setMessageBox({ show: true, title: 'Alumno eliminado', content: 'El alumno ha sido eliminado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) }); } catch (error) { setMessageBox({ show: true, title: 
'error', onClose: () => setMessageBox({ ...messageBox, show: false }) }); console.error("Error deleting student:", error); } finally { setLoading(false); } }, onClose: () => setMessageBox({ ...messageBox, show: false }) });
}; const sendWhatsApp = (phone) => { const formattedPhone = phone.replace(/\D/g, ''); const url = `https://wa.me/${formattedPhone}`; window.open(url, '_blank'); };
const addPayment = async () => { if (!dbRef.current || !userId) return;
if (!newPayment.date || !newPayment.amount || newPayment.amount <= 0) { setMessageBox({ show: true, title: 'Error de validación', content: 'Por favor, ingresa una fecha y un monto válido para el pago.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
return; } try { setLoading(true); const paymentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments');
const paymentData = { ...newPayment, amount: parseFloat(newPayment.amount), date: newPayment.date, timestamp: window.Timestamp.fromDate(new Date(newPayment.date)) };
if (isEditingPayment) { const paymentDocRef = window.doc(paymentsColRef, editedPaymentId); await window.setDoc(paymentDocRef, paymentData);
setMessageBox({ show: true, title: 'Pago actualizado', content: 'El pago se ha actualizado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} else { await window.addDoc(paymentsColRef, paymentData); setMessageBox({ show: true, title: 'Pago añadido', content: 'El nuevo pago se ha añadido exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
} setNewPayment({ date: new Date().toISOString().split('T')[0], amount: 0, description: '' }); setIsEditingPayment(false); setEditedPaymentId(null);
} catch (error) { setMessageBox({ show: true, title: 'Error al guardar el pago', content: 'Hubo un error al guardar los datos del pago. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error adding/updating payment:", error); } finally { setLoading(false); } };
const editPayment = (paymentToEdit) => { setNewPayment({ ...paymentToEdit, amount: paymentToEdit.amount.toString() }); setIsEditingPayment(true); setEditedPaymentId(paymentToEdit.id); };
const deletePayment = (paymentId) => { setMessageBox({ show: true, title: 'Confirmar eliminación', content: '¿Estás seguro de que quieres eliminar este pago? Esta acción es irreversible.', type: 'confirm', onConfirm: async () => { if (!dbRef.current || !userId) return; try { setLoading(true); const paymentDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments', paymentId); await window.deleteDoc(paymentDocRef); setMessageBox({ show: true, title: 'Pago eliminado', content: 'El pago ha sido eliminado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) }); } catch (error) { setMessageBox({ show: true, title: 
'error', onClose: () => setMessageBox({ ...messageBox, show: false }) }); console.error("Error deleting payment:", error); } finally { setLoading(false); } }, onClose: () => setMessageBox({ ...messageBox, show: false }) });
}; useEffect(() => { if (userId && dbRef.current) { loadCustomPrices(); const classesColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'classes'); const classesQuery = window.query(classesColRef); const unsubscribeClasses = window.onSnapshot(classesQuery, (snapshot) => { const fetchedClasses = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const sortedClasses = fetchedClasses.sort((a, b) => new Date(b.date) - new Date(a.date)); setClasses(sortedClasses); }); const studentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'students'); const studentsQuery = window.query(studentsColRef); const unsubscribeStudents = window.onSnapshot(studentsQuery, (snapshot) => { const fetchedStudents = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); setStudents(fetchedStudents.sort((a, b) => a.lastName.localeCompare(b.lastName))); }); const paymentsColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'clubPayments');
const paymentsQuery = window.query(paymentsColRef); const unsubscribePayments = window.onSnapshot(paymentsQuery, (snapshot) => { const fetchedPayments = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const sortedPayments = fetchedPayments.sort((a, b) => new Date(b.date) - new Date(a.date)); setPayments(sortedPayments); });
const logColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'activityLog'); const logQuery = window.query(logColRef);
const unsubscribeLog = window.onSnapshot(logQuery, (snapshot) => { const fetchedLog = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); const sortedLog = fetchedLog.sort((a, b) => b.timestamp.seconds - a.timestamp.seconds); setActivityLog(sortedLog); });
return () => { unsubscribeClasses(); unsubscribeStudents(); unsubscribePayments(); unsubscribeLog(); }; } else { setClasses([]); setStudents([]); setPayments([]); setActivityLog([]); } }, [userId]);
useEffect(() => { if (Object.keys(customPrices).length > 0) { setNewEntry(prev => ({ ...prev, price: customPrices[prev.studentCount] || 0 })); } }, [customPrices]);
useEffect(() => { const report = {}; classes.forEach(cls => { const date = new Date(`${cls.date}T00:00:00Z`); const monthYear = `${date.getUTCFullYear()}-${(date.getUTCMonth() + 1).toString().padStart(2, '0')}`; if (!report[monthYear]) { report[monthYear] = { totalIncome: 0, classCount: 0, classCountByStudent: {} }; } report[monthYear].totalIncome += cls.price; report[monthYear].classCount += 1; const studentCount = cls.studentCount; report[monthYear].classCountByStudent[studentCount] = (report[monthYear].classCountByStudent[studentCount] || 0) + 1; }); setMonthlyReports(report); }, [classes]);
useEffect(() => { const report = {}; payments.forEach(payment => { const year = new Date(payment.date).getUTCFullYear(); if (!report[year]) { report[year] = { totalAmount: 0, paymentCount: 0 }; } report[year].totalAmount += payment.amount; report[year].paymentCount += 1; }); setAnnualPaymentsReport(report); }, [payments]);
const handleNewEntryChange = (e) => { const { name, value } = e.target;
if (name === 'studentCount') { const count = parseInt(value); const newNames = Array(count).fill(''); const newPrice = customPrices[count] || 0;
setNewEntry(prev => ({ ...prev, studentCount: count, studentNames: newNames, price: newPrice })); } else if (name.startsWith('studentName-')) { const index = parseInt(name.split('-')[1]);
const newNames = [...newEntry.studentNames]; newNames[index] = value; setNewEntry(prev => ({ ...prev, studentNames: newNames }));
} else { setNewEntry(prev => ({ ...prev, [name]: value })); } };
const handleDateChange = (e) => { const dateString = e.target.value; const dateObj = new Date(`${dateString}T00:00:00Z`); const dayOfWeek = daysOfWeek[dateObj.getUTCDay()];
setNewEntry(prev => ({ ...prev, date: dateString, day: dayOfWeek })); };
const handleCustomPriceChange = (studentCount, price) => setCustomPrices(prev => ({ ...prev, [studentCount]: parseInt(price) || 0 }));
const addClass = async () => { if (!dbRef.current || !userId) return;
if (newEntry.studentNames.some(name => name.trim() === '') || newEntry.price <= 0) { setMessageBox({ show: true, title: 'Error de validación', content: 'Por favor, completa todos los campos de los alumnos y el precio.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
return; } try { setLoading(true); const classesColRef = window.collection(dbRef.current, 'artifacts', appId, 'users', userId, 'classes');
const selectedStudents = newEntry.studentIds.map(id => { const stu = students.find(s => s.id === id); return stu ? `${stu.firstName} ${stu.lastName}` : ""; });
const classData = { ...newEntry, studentIds: newEntry.studentIds, studentNames: selectedStudents, timestamp: window.Timestamp.fromDate(new Date(newEntry.date)), };
if (isEditing) { const classDocRef = window.doc(classesColRef, editedClassId); await window.setDoc(classDocRef, classData);
setMessageBox({ show: true, title: 'Clase actualizada', content: 'La clase se ha actualizado exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
addLogEntry('Clase editada', `Clase con ${classData.studentNames.join(', ')} editada el día ${classData.date} a las ${classData.time}.`); } else { await window.addDoc(classesColRef, classData);
setMessageBox({ show: true, title: 'Clase añadida', content: 'La nueva clase se ha añadido exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) });
addLogEntry('Clase añadida', `Clase con ${classData.studentNames.join(', ')} añadida para el día ${classData.date} a las ${classData.time}.`);
} setNewEntry({ studentCount: 1, studentNames: [''], studentIds: [''], date: new Date().toISOString().split('T')[0], day: daysOfWeek[new Date().getDay()], time: timesOfDay[0], price: customPrices[1] || 0, });
setIsEditing(false); setEditedClassId(null); } catch (error) { setMessageBox({ show: true, title: 'Error al guardar la clase', content: 'Hubo un error al guardar los datos de la clase. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) });
console.error("Error adding/updating class:", error); } finally { setLoading(false); } };
const deleteClass = (id, classData) => { setMessageBox({ show: true, title: 'Confirmar eliminación', content: '¿Estás seguro de que quieres eliminar esta clase? Esta acción es irreversible.', type: 'confirm', onConfirm: async () => { if (!dbRef.current || !userId) return; try { setLoading(true); const classDocRef = window.doc(dbRef.current, 'artifacts', appId, 'users', userId, 'classes', id); await window.deleteDoc(classDocRef); setMessageBox({ show: true, title: 'Clase eliminada', content: 'La clase ha sido eliminada exitosamente.', type: 'success', onClose: () => setMessageBox({ ...messageBox, show: false }) }); addLogEntry('Clase eliminada', `Clase con ${classData.studentNames.join(', ')} del día ${classData.date} a las ${classData.time} ha sido eliminada.`); } catch (error) { setMessageBox({ show: true, title: 
'Error al eliminar', content: 'Hubo un error al eliminar la clase. Inténtalo de nuevo.', type: 'error', onClose: () => setMessageBox({ ...messageBox, show: false }) }); console.error("Error deleting class:", error);
} finally { setLoading(false); } }, onClose: () => setMessageBox({ ...messageBox, show: false }) }); };
const editClass = (classToEdit) => { setNewEntry({ studentCount: classToEdit.studentCount, studentNames: classToEdit.studentNames, date: classToEdit.date, day: classToEdit.day, time: classToEdit.time, price: classToEdit.price, });
setIsEditing(true); setEditedClassId(classToEdit.id); setView('list'); }; const generatePDF = () => { if (!reportTableRef.current) return; setLoading(true); const input = reportTableRef.current;
window.html2canvas(input, { scale: 2 }).then((canvas) => { const imgData = canvas.toDataURL('image/png'); const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4'); const imgWidth = 210; const pageHeight = 295; const imgHeight = canvas.height * imgWidth / canvas.width; let heightLeft = imgHeight; let position = 0; pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight; while (heightLeft >= 0) { position = heightLeft - imgHeight; pdf.addPage(); pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); heightLeft -= pageHeight; } pdf.save(`informe_clases.pdf`); setLoading(false); }).catch(err => { console.error("Error generating PDF:", err); setLoading(false); });
}; const generateAnnualPaymentsPDF = () => { if (!annualPaymentsReportRef.current) return; setLoading(true); const input = annualPaymentsReportRef.current;
window.html2canvas(input, { scale: 2 }).then((canvas) => { const imgData = canvas.toDataURL('image/png'); const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4'); const imgWidth = 210; const pageHeight = 295; const imgHeight = canvas.height * imgWidth / canvas.width; let position = 0; pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight); pdf.save(`informe_pagos_anual_${new Date().getFullYear()}.pdf`); setLoading(false); }).catch(err => { console.error("Error generating PDF:", err); setLoading(false); });
}; const uniqueMonths = useMemo(() => { const months = new Set(); classes.forEach(cls => { const monthYear = cls.date.substring(0, 7); months.add(monthYear); }); return Array.from(months).sort((a, b) => new Date(a) - new Date(b)); }, [classes]);
const filteredClasses = useMemo(() => { let filtered = classes; if (selectedMonthYear) { filtered = filtered.filter(cls => cls.date.startsWith(selectedMonthYear)); } if (filterText) { filtered = filtered.filter(cls => cls.studentNames.some(name => name.toLowerCase().includes(filterText.toLowerCase()))); } return filtered; }, [classes, selectedMonthYear, filterText]);
const indexOfLastClass = currentPage * classesPerPage; const indexOfFirstClass = indexOfLastClass - classesPerPage; const currentClasses = filteredClasses.slice(indexOfFirstClass, indexOfLastClass);
const totalPages = Math.ceil(filteredClasses.length / classesPerPage); const DailyReportView = () => { const [selectedDate, setSelectedDate] = React.useState(new Date());
// Formato YYYY-MM-DD para comparar con `cls.date` const selectedDateStr = selectedDate.getFullYear() + '-' + String(selectedDate.getMonth() + 1).padStart(2, '0') + '-' + String(selectedDate.getDate()).padStart(2, '0');
...
}

   </div>
           )}
         </main>
       </div>
     );
   };

   ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>
